# -*- coding: utf-8 -*-
"""NLCC_general_input.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xr_JIVHlTv4liKdMLAwK06RcnHPBYK_M
"""

import numpy as np
import scipy as sp
from scipy import stats
from scipy import special
import numpy.random as rnd
import matplotlib.pyplot as plt

def Nonlinearity(x):
  """ A STRICTLY increasing function for channel nonlinearity

  Smoother functions work better

  """
  y = x/((1+x**4)**(1/4))
  # y = np.tanh(x)
  return y

def Zero_Insert_Matrix(M, K):
  """ A matrix is created by inserting K zero rows
  in between every row of an M x M identity matrix

  When an Mx1 vector is multiplied with this matrix
  K zeros are inserted between every element.

  Useful for preparing forconvolution of two signals
  (or distributions) with different bases/supports.
  """
  ID_matrix = np.eye(M)

  # Number of rows in the resulting matrix
  rows = M + K * (M - 1)

  # Initialize the resulting matrix with zeros
  result_matrix = np.zeros((rows, M))

  # Create an index array to place the identity matrix rows
  Idx = np.arange(0, rows, K + 1)

  # Use advanced indexing to place the identity matrix rows
  result_matrix[Idx] = ID_matrix

  return result_matrix

def sum_values_by_intervals(y_pts, f_y, bin_width=0.001):
  # Ensure Y and X are numpy arrays
  y_pts = y_pts.reshape([-1])

  # Define the bin edges based on the given bin width
  bin_edges = np.arange(-1, 1 + bin_width, bin_width)

  # Digitize Y to find which bin each element falls into
  bin_indices = np.digitize(y_pts, bin_edges, right=False) - 1  # Make bin indices zero-based

  # Compute the sums for each bin using np.bincount
  # np.bincount expects non-negative integers, so bin_indices should be zero-based
  f_y_update = np.bincount(bin_indices, weights=f_y, minlength=len(bin_edges) - 1)

  return f_y_update

def Quantized_Gaussian2(delta,
                       max_std,
                       varx = np.array(1.0),
                       mean = np.array(0.0)):
  """ Quantized Gaussian distribution (2nd version)

  - delta : Quantization bin/interval size
  - max_std : How many std deviations away from the mean
  the quantized points are placed (approximately)
  - varx : default is 1.0, scalar or vector of variances
  - mean : default is 0.0, scalar or vector of variances,
           if vector should be same size as varx

  Divides real line into N bins of equal size that span.

  Tail probabilities are added to
  edge bins.

  Returns
  f_x : the quantized (discrete) distribution that sums to 1 and has
  N points. (Always a vector of size N)
  delta_x : quantization interval sqrt(varx)*2*max_std/(N-1), same
  size as varx
  x_pts : The support of the quantized Gaussian distribution on the
  real line, size len(varx) x N
  """

  # Calculate how many points we need between -max_std and max_std with
  # delta intervals
  std = np.sqrt(varx.astype(float))
  N_approx = 2*std*max_std/delta + 1.0
  N = int(N_approx)

  # To make sure we have delta intervals and N points we adjust limits
  max_std_approx = (N-1)*delta/( 2.0*np.sqrt(varx) )

  # The points (for standard Gaussian) of quantization
  x_pts = np.linspace(-max_std_approx,max_std_approx,N)

  # N+1 boundaries
  x_bnds = np.append(x_pts - delta/2, x_pts[-1] + delta/2)

  # CDF of Gaussian is used to get each bin's probability
  CDF_x = 0.5 + 0.5*special.erf(x_bnds/np.sqrt(2))

  # Adding tail probabilities
  CDF_x[0] = 0
  CDF_x[-1] = 1

  # Probabilities are obtained by getting differences
  f_x = np.ediff1d(CDF_x)

  # The points are reshaped into desired output form and scaled properly
  # according to variance and mean input
  x_pts.reshape([1,N])
  x_pts = x_pts*np.sqrt( varx.reshape( [-1,1] ) ) + mean.reshape( [-1,1] )

  # interval is adjusted for the variance
  # delta_x = delta*np.sqrt( varx.reshape( [-1,1] ) )

  return f_x, x_pts

def entropy_Y_general(f_x,
              x_pts,
              delta_x,
              delta_z, max_std, varz = np.array(1.0),
              phi = lambda x: x,
              eps = 1e-20):

  """ Calculates (approx) differential entropy of h(Y) for Y = phi( X + Z )
  where Z is a Gaussian noise to the input X

  f_x : PMF (or approx PDF) of X
  x_points : Support of X
  delta_x : interval between the support of X, assumed to be uniform across all
  x and

  delta_z, max_std : parameters for approximating the Gaussian distribution.
  Check help(Quantized_Gaussian2) for more details

  phi : the nonlinearity function (default is the identity function)

  eps: avoids division by zero, results are sensitive when support of x is large
  and varz

  NOTE: delta_x is assumed to be INTEGER MULTIPLE of delta_z to correctly
  calculate the convolution
  """
  # Get noise PDF
  f_z, z_pts = Quantized_Gaussian2(delta_z, max_std, varz)

  # Factor of scaling of the bases (we need to insert zeros between f_x to
  # properly take, then we get the proper scaling matrix and obtain scaled f_x
  K = int(delta_x/delta_z) - 1
  M = len(f_x)
  Scale_Mat = Zero_Insert_Matrix(M, K)
  f_x_scaled = np.dot(Scale_Mat, f_x)

  # PDF of X + Z
  f_u = sp.signal.convolve(f_x_scaled, f_z)

  # Calculate support of u[0,1]
  u_min = x_pts[0,0] + z_pts[0,0]
  u_max = x_pts[0,-1] + z_pts[0,-1]
  u_pts = np.linspace(u_min, u_max, len(f_u))

  # Pseudo-boundaries of the support of u
  u_bnds = np.append(u_pts - delta_z/2, u_pts[-1] + delta_z/2)

  # Transformation of the boundaries under the nonlinearity
  y_bnds = phi(u_bnds)
  delta_y = np.ediff1d(y_bnds) + eps
  h_y = np.sum(-f_u*np.log(f_u/delta_y))


  # Different method
  # y_pts = (y_bnds[1:] + y_bnds[:-1]) / 2
  # delta_y = 1e-2
  # f_y_update =  sum_values_by_intervals(y_pts, f_u, delta_y)
  # h_y2 = stats.entropy(f_y_update) + np.log(delta_y)


  return h_y.reshape(-1,)

def entropy_Y_given_X_general(f_x,
                              x_pts,
                              delta_z, max_std, varz = np.array(1.0),
                              phi = lambda x: x,
                              eps = 1e-30):

  """ Calculates (approx) conditional differential entropy h(Y|X) for
  Y = phi( X + Z ) where Z is a Gaussian noise to the input X

  f_x : PMF (or approx PDF) of X
  x_points : Support of X

  delta_z, max_std : parameters for approximating the Gaussian distribution.
  Check help(Quantized_Gaussian2) for more details

  and phi is the nonlinearity function (default is the identity function)

   eps: avoids division by zero, results are sensitive for high varx and varz
  """
  eps = 1e-20

  Nx = len(f_x)
  f_x = f_x.reshape([Nx,1])
  x_pts = x_pts.reshape([Nx,1])

  f_u_gx, u_pts_gx = Quantized_Gaussian2(delta_z, max_std, varz, mean = x_pts)

  Nz = len(f_u_gx)
  f_u_gx = f_u_gx.reshape([1,Nz])

  u_bnds_gx = np.append(u_pts_gx - delta_z/2,
                     u_pts_gx[:,-1].reshape([ -1 , 1]) + delta_z/2,axis=1)

  u_bnds_gx = np.reshape(u_bnds_gx,[-1,Nz+1])


  y_bnd_gx = phi(u_bnds_gx)

  delta_y = np.diff(y_bnd_gx,axis=1)

  h_y_Gx = np.dot(np.sum(-f_u_gx*np.log( (f_u_gx)/
                                         (delta_y + eps) ),
                                         axis=1).reshape([1,-1]), f_x)


  return h_y_Gx.reshape(-1,)

# Test on Gaussian input

delta_z = 0.01
max_std = 4.0
varz = 1.0

Gaussian_ach = [] #why are these lists ????
AWGN_capacity = []
SNR_list = []

for i in range(1, 11):
  delta_x = i*delta_z
  varx = varz*(i**2)
  f_x, x_pts = Quantized_Gaussian2(delta_x, max_std, np.array(varx))

  h_y  = entropy_Y_general(f_x, x_pts, delta_x, delta_z, max_std,
                          np.array(varz), Nonlinearity)
  h_y_Gx = entropy_Y_given_X_general(f_x, x_pts, delta_z, max_std,
                                     np.array(varz), Nonlinearity)
  Gaussian_ach.append(h_y-h_y_Gx)
  AWGN_capacity.append(0.5*np.log(1+varx/varz))
  SNR_list.append(10*np.log10(varx/varz))

plt.plot(SNR_list,AWGN_capacity,label='AWGN Capacity',marker = 'x')
plt.plot(SNR_list,Gaussian_ach,label='Gaussian_ach '+ r'$\tanh(x)$',marker = 'o')
plt.legend(loc='upper left')
plt.xlim([0.0,20.0])
plt.xlabel('SNR (dB)')
plt.ylabel('Rate (nats)')
plt.grid(True)
plt.show()

A = np.tanh(21.00) - np.tanh(20.00)
1/A